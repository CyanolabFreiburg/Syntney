
# GLASSgo postprocessing script

# dependencies: 
## CDhit
require(seqinr)
require(RSQLite)
require(rentrez)
require(phangorn)
require(stringi)
# parameters from function call:

#CALL:
#R --slave -f  /home/jens/jensSicherung/GLASSgo2/GLASSgo_postprocessing_2.r --args filename=sRNA.txt duplicates_allowed=TRUE synteny_window=3000 refpath=/media/cyano_share/data/GLASSgo_postprocessing/accession_to_refseq cop_path=/media/cyano_share/data/GLASSgo_postprocessing/CopraRNA_available_organisms.txt featpath=/media/cyano_share/data/GLASSgo_postprocessing/GLASSgo_genome_tables_cop_only2.db name=testfile coprarna_compatible=TRUE
#R --slave -f  /home/jens/jensSicherung/GLASSgo2/GLASSgo_postprocessing_6.r --args filename="sRNA.txt" duplicates_allowed=FALSE synteny_window=3000  name=FnrS coprarna_compatible=TRUE ooi=NC_000913


duplicates_allowed<-F  # if FALSE only one homolog from one organism is plotted
name<-"sRNA"  # name of the investigated sRNA
filename<-"spot42.txt" # result fasta file from GLASSgo
refpath<-"/home/steffen/media/cyano_share/data/GLASSgo_postprocessing/accession_to_refseq" # look-up table for refseq assignment updated with "update_accession_to_refseq.r"
cop_path<- "/home/steffen/media/cyano_share/data/GLASSgo_postprocessing/CopraRNA_available_organisms.txt" # same file as for CopraRNA


synteny_window<-3000 # number of bases upstream and downstream of the sRNA that were searched for protein coding genes for the synteny analysis
ooi<-"NC_000913" # organism of interest - important for the CopraRNA organism selection
dbname_16S<-"/home/steffen/media/cyano_share/data/GLASSgo_postprocessing/rRNA.db" # path to the SQLite database storing SILVA 16S rDNA sequences
coprarna_compatible<-F # organsims are filtered based on the CopraRNA_available_organisms.txt file

maxorgs<-20 # number of orgs for CopraRNA prediction
mindis<-0.005 # organisms which have a lower cophonetic distances to each other in a 16S phylogentic tree are excluded to reduce complexity. A respective reference organism is kept
maxdis<-0.04 # # organisms which have a higher cophonetic distances to each the ooi are excluded.
closeorgs<-3 # number of closest relatives to the ooi for CopraRNA
clustervalue<-1.5 # the higher the higher the resolution of tree sub-groups
wildcard<-c("NZ_CP007542.1")
refseq_required=F
outorg="internal" # genome accssion of outgroup organsim for phylogenetic tree, if "internal" organism with highest distance to ooi is selected as outgroup
min_size<-4  # minimal size of tree-based cluster
mixed_sources=F # True if several GLAssgo outputs are pasted together
reduced_svg=F


args <- commandArgs(trailingOnly = TRUE) 

for(i in 1:length(args)){
	temp<-strsplit(args[i],"=")
	temp<-temp[[1]]
	temp1<-temp[1]
	temp2<-temp[2]
	assign(as.character(temp1),temp2)
 }
 
duplicates_allowed<-as.logical(duplicates_allowed)
synteny_window<-as.numeric(synteny_window)





split_glassgo<-function(x){
	tmp<-strsplit(x[1], ">")[[1]]
	if(length(tmp)>2){
		tmp2<-strsplit(tmp[length(tmp)],"p.c.VAL:")[[1]]
		tmp2<-gsub(";.*","",tmp2[length(tmp2)])
		tmp<-paste(tmp[2], "p.c.VAL:", tmp2[length(tmp2)], sep="")
	}else {
			tmp<-tmp[2]
		}
	tmp<-strsplit(tmp, ":")[[1]]
	id<-tmp[1]
	taxid<-tmp[length(tmp)]
	identity<-strsplit(tmp[length(tmp)-1],"-taxID")[[1]][1]
	tmp2<-strsplit(tmp[2]," ")[[1]]
	tmp3<-paste(tmp2[2:(length(tmp2)-1)],collapse=" ")
	name<-strsplit(tmp3,",")[[1]][1]
	tmp2<-strsplit(tmp2,"-")[[1]]
	a<-tmp2[1]
	b<-tmp2[2]
	a<-strsplit(a,"c")[[1]]
	strand<-"+"
	if(length(a)==2){
		st<-b
		en<-a[2]
		strand<-"-"
	}else{
		st<-a
		en<-b
	}
	out<-c(id, strand, st,en,name)
	out
}

export_ncRNA_coordinates<-function(x){ 
	header_row <- grep(">", x)
	headers <- as.character(x[header_row])
	headers<-headers[2:length(headers)]
	seqs<-as.character(x[header_row+1])
	seqs<-seqs[2:length(seqs)]
	tmp<-do.call(rbind,lapply(headers,split_glassgo))
	tmp<-cbind(tmp,headers,seqs)
	colnames(tmp)<-c("Accesion_number", "Strand","start","end","name","Full_header","sequence")
	tmp
}


locus_tag2org<-function(out2){
	tag<-c()
	org<-c()
	for(i in 1:length(out2)){
		temp_tag<-out2[[i]][,5]
		temp_org<-rep(names(out2)[i], length(temp_tag))
		tag<-c(tag,temp_tag)
		org<-c(org,temp_org)
	}
	out<-cbind(tag,org)
	out
}

to_refseq2<-function(result, refpath="../accession_to_refseq"){
		load(refpath)
		result<-gsub("\\..*","",result)
		temp<-c()
		
		for(i in 1:length(result)){
		temp1<-grep(result[i],ref[,"full_genome_entry"])
		temp<-c(temp,temp1[1])
		}
		temp<-ref[temp,"Chromosomes.RefSeq"]
		refseq<-temp
		refseq
	}

rand_extension<-function(x, Accession){
	ra<-stri_rand_strings(x,length=4,  pattern = "[A-Za-z0-9]")
	temp<-paste(Accession,ra,sep="_")
	#temp<-gsub("\"","",temp)
	
	temp
}


divide<-function(number,candlist,p4,max_step=5,ooi){
	ooi_p<-grep(ooi, colnames(p4))
	#p5<-names(sort(p4[,ooi_p))
	more<-0
	stepsize<-floor(length(candlist)/number)
	stepsize<-min(max_step,stepsize)
	if(number>1){
		sel<-seq(1,length(candlist)*2,by=stepsize)
		sel<-sel[1:number]
		sel<-na.omit(sel)
		more<-number-length(sel)
		if(length(candlist)>1){
			cands<-names(sort(p4[candlist,ooi_p]))
		}
		if(length(candlist)==1){
			cands<-rownames(p4)[candlist]
		}
	}
	if(number==1){
		sel<-1
		#cands<-rownames(p4)[candlist]
		if(length(candlist)>1){
			cands<-names(sort(p4[candlist,ooi_p]))
		}
		if(length(candlist)==1){
			cands<-rownames(p4)[candlist]
		}
	}
	
	sel<-cands[sel]
	if(more>0){
		r<-setdiff(cands,sel)
		sel<-c(sel,r[1:more])
		}	
	#print(c(i,sel))
	sel	
}

get_prot_fasta3<-function(out){
  fasta<-c()
  for(i in 1:length(out)){
    for(j in 1:nrow(out[[i]])){
        if(is.na(out[[i]][j,6])==F){
        temp<-as.character(out[[i]][j,6])
		na<-as.character(out[[i]][j,5])
		na<-gsub("\\\"","",na)
         na<-paste(">",na,sep="")
		 temp<-c(na,temp)
         fasta<-c(fasta,temp)
        }
      }
    }
  write.table(fasta, file="protein_fasta.txt", sep="\t", col.names=FALSE, row.names=FALSE, quote=FALSE)
}


# identify homologous proteins using CDhit
cdhit_run<-function(fasta="protein_fasta.txt", outname="psi", thres=0.3, psi=T){
  wd<-getwd()
  di<-paste(wd,"/", "psi_out",sep="")
  dir.create(di)
  if(psi==T){
    inp<-paste("./psi-cd-hit.pl -i ", fasta,  " -d 50 -g 1 -o ", di,"/",outname, " -c ", thres, sep="")
  }
  if(psi==F){
    inp<-paste("cd-hit -i ", fasta,  " -d 50 -g 1 -o ", di,"/",outname, " -c ",  thres ," -n 2", " -aL 0.6", sep="")
  }
  print(inp)
  system(inp)
  cd<-paste(di, "/", outname, ".clstr", sep="")
  cd<-read.delim(cd, header=F, sep="?")
  cd<-as.character(cd[,1])
  cd<-gsub("\t"," ", cd)
  cd
}

proc_cdhit<-function(x){ 
  clustlist<-list()
  numb<-grep(">Cluster", x)
  for(i in 1:length(numb)){
    if(i<length(numb)){
      end<-numb[i+1]-1
    }
    if(i==length(numb)){
      end<-length(x)
    }
    temp<-x[(numb[i]+1):end]
    temp<-gsub(".*aa, >","",temp)
    temp<-gsub("\\.\\.\\..*","",temp)
    clustlist[[i]]<-temp
  }
  clustlist	
}

# plot a pdf visualizing the synteny of predicted sRNA homologs


plot_function4<-function(out, cdhit_result, wind=3000, outformat="cairo_pdf", fasta="sRNA"){ 
  cdl<-unlist(lapply(cdhit_result,length))
  one<-which(cdl==1)
  more<-which(cdl>1)
  nl<-length(more)
  color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
  while(length(more)>length(color)){
	color<-c(color,color)
  }
  if(length(more)>0){
    collist<- sample(color, nl)
    for(i in 1:length(more)){
      names(cdhit_result)[more[i]]<-collist[i]
    }
  }
  names(cdhit_result)[one]<-"grey"
  numb<-ceiling(length(out)/5)
  
  
  
  le<-length(out)
  
   count<-4*le+1
	if(outformat=="pdf"){
	nam<-paste(fasta,"_synteny.pdf",sep="")
	pdf(nam,width=12, height=le*0.9,  useDingbats=F)
	#cairo_pdf(nam,width=11,  height = 1.1*le)
  }
  if(outformat=="png"){
	nam<-paste(fasta,"_synteny.png",sep="")
	png(nam,width=11,  height = 1.1*le,units="in", res=100)
  }
  if(outformat=="svg"){
	nam<-paste(fasta,"_synteny.svg",sep="")
	svg(nam,width=11,  height = 1.1*le)
  }
	for( i in 1:le){
		if(out[[i]][1,11]==-1){
		temp<-out[[i]]
		temp[,11]<-rep(1,nrow(temp))
		ma<-max(temp[,8])
		plus<-which(temp[,1]=="+")
		minus<-which(temp[,1]=="-")
		if(length(plus)>0){
			temp[plus,1]<-"-"
		}
		if(length(minus)>0){
			temp[minus,1]<-"+"
		}
			for(j in 1:nrow(temp)){
				temp[j,8]<-ma-out[[i]][j,7]
				temp[j,7]<-ma-out[[i]][j,8]
				temp[j,10]<-ma-out[[i]][j,9]
				temp[j,9]<-ma-out[[i]][j,10]
				}
			out[[i]]<-temp	
		}
		
	}
	
	#mas<-out[[1]][1,9]
	mas<-wind
	 for(i in 1:le){
		 te<-out[[i]]
		 s2<-mas-as.numeric(te[1,9])
		for(ii in 1:nrow(te)){
        
         
		 #print(as.numeric(te[1,9])[1])
        #s<-c(s,s2+mas)
         #se<-c(se,s2+mi)
         te[ii,7]<-as.numeric(te[ii,7])+s2
         te[ii,8]<-as.numeric(te[ii,8])+s2
         te[ii,9]<-as.numeric(te[ii,9])+s2
         te[ii,10]<-as.numeric(te[ii,10])+s2
         
		}
		out[[i]]<-te
     }
	
  #
  
  
  
  d_vect<-c()
  s_vect<-c()
  # for(i in 1:numb){
     #count2<-i*5
     #count2<-count2-5
    # mas<-c()
    # mi<-c()
    # for(ii in 1:5){
      # tryCatch({
        # te<-(out[[count2+ii]])
        # mas<-c(mas,max(as.numeric(te[,8])))
        # mi<-c(mi,min(as.numeric(te[,7])))

      # }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    # }
    # mas<-max(mas)
    # mi<-min(mi)
    # s<-c()
    # se<-c()
	
	
	
	
	
	
	
    
    # s<-max(s)
	# null<-which(se==0)
	# se<-min(se)
    # d_vect<-c(d_vect,s)	
    # s_vect<-c(s_vect,se)
  # }
  #for(jj in 1:le){
   # d<-d_vect[jj]
    #s<-s_vect[jj]
   #par(mar = c(-10, 5, -10, 5))
    #plot(1,1, type="n",xlim=c(s,d*1),ylim=c(0,5*5),xaxt="n",yaxt="n",xlab="",ylab="")	
	plot(1,1, type="n",xlim=c(1,wind*2),ylim=c(1,count),xaxt="n",yaxt="n",xlab="",ylab="", bty="n")
    for(i in 1:le){
     # if((i+(jj-1)*5)<=length(out)){
        temp<-out[[i]]

        mi<-min(as.numeric(temp[,7]))
        ma<-max(as.numeric(temp[,8]))

        lines(c(mi,ma),c(1+count-i*4,1+count-i*4))
        lines(c(mi,ma),c(2+count-i*4,2+count-i*4))
        for(j in 1:nrow(temp)){

          m<-(as.numeric(temp[j,8])-as.numeric(temp[j,7]))/2+as.numeric(temp[j,7])
          mm<-as.numeric(temp[j,8])-as.numeric(temp[j,7])
          n<--1
          if(temp[j,1]=="+"){
            n<-1
          }
          if(n==-1){
            n<-0
          }
          color<-"white"
          tcolor<-na.omit(grep(temp[j,5],cdhit_result))
          tcolor2<-na.omit(grep(temp[j,4],cdhit_result))
          tcolor<-c(tcolor,tcolor2)
          if(length(tcolor)>0){
             color<-names(cdhit_result)[tcolor]
           }
          rect(as.numeric(temp[j,7]),0.5+n+count-i*4,as.numeric(temp[j,8]),1.5+n+count-i*4, col=color)
          text(m,n+count-i*4+1+0.25,gsub("\"","",gsub("NA ","",gsub("orf.*","",temp[j,4]))),cex=0.4,font=4)
		  text(m,n+count-i*4+1-0.25,gsub("\"","",temp[j,5]),cex=0.4,font=4)
        }
        n<-as.numeric(temp[1,11])
        if(n==-1){
          n<-0
        }
        rect(as.numeric(temp[j,9]),0.5+n+count-i*4,as.numeric(temp[j,10]),1.5+n+count-i*4, col=2)
        text(wind,count-i*4,temp[j,12], cex=0.8, font=4)
       # count<-count-4
     # }		
    }
 dev.off()	

}

#plot_function4(out2[[1]],cd,wind=synteny_window,outformat="pdf", fasta=name)

# call mafft for MSA
mafft<-function(filename="ncrna.fa", outname="ncrna_aligned.fa", mode="fast"){
	if(mode=="accurate"){
		command<-paste("mafft --maxiterate 1000 --localpair --quiet --inputorder ", filename, " > ", outname, sep="" )
	}
	if(mode=="fast"){
		command<-paste("mafft --retree 2 --maxiterate 0 --quiet --inputorder ", filename, " > ", outname, sep="" )
	}
	if(mode=="very_fast"){
		command<-paste("mafft --retree 1 --maxiterate 0 --quiet --inputorder ", filename, " > ", outname, sep="" )
	}
	system(command)
} 

# function to exclude very similar organism based on a phylogentic tree to reduce complexity
exclude_similars<-function(dis, thres=0.01,ooi){
i<-1

o<-grep(ooi, rownames(dis))
nam<-colnames(dis)[o]
	temp<-which(dis[,o]<=thres)
	nam<-na.omit(match(nam, rownames(dis)))
	nam<-na.omit(match(nam, temp))
	if(length(nam)>0){
		temp<-temp[-nam]
	}
	
	if(length(temp)>0){
		dis<-dis[-temp,-temp]
		
	}
	



while(nrow(dis)>i){
	
	nam<-colnames(dis)[i]
	temp<-which(dis[,i]<=thres)
	nam<-na.omit(match(nam, rownames(dis)))
	nam<-na.omit(match(nam, temp))
	if(length(nam)>0){
		temp<-temp[-nam]
	}
	
	if(length(temp)>0){
		dis<-dis[-temp,-temp]
		
	}
	i<-i+1
}
dis
}



# Execute functions



fasta<-read.delim(filename, header=F, sep="\t")
fasta<-as.character(fasta[,1])
coor<-export_ncRNA_coordinates(fasta)

#if more than 1 homolog is detected for one organism or the same Refseq ID, keep only the homolog with the highest identity to the input
if(mixed_sources==F){
	iden<-gsub(".*VAL:","",coor[,"Full_header"])
	iden<-as.numeric(gsub("%.*","",iden))
	coor<-cbind(coor,iden)
	coor<-coor[order(iden, decreasing=T), ]
}


if(mixed_sources==T){
	mafft(filename=filename,outname="aligned_sRNA.fasta")
	dat<-read.phyDat("aligned_sRNA.fasta", format="fasta", type="DNA")
	dm <- dist.hamming(dat)
	dm<-as.matrix(dm)
	iden<-dm[,1]
	coor<-cbind(coor,iden)
	coor<-coor[order(iden, decreasing=F), ]
}
#coor<-coor[-1,]
if(duplicates_allowed==F){
	dup<-which(duplicated(coor[,1]))
	if(length(dup)>0){
	coor<-coor[-dup,]
	}
}

coor2<-coor
taxi<-gsub(".*taxID:","",coor[,"Full_header"])

# assign matching Refseq ID based on the Accesion Number
load(refpath)
fin<-match(coor[,1],ref[,1])
fin<-ref[fin,2]
coor<-cbind(coor,taxi,fin)

# remove entries with duplicated Refseq ID and entries without matching Refseq ID
if(duplicates_allowed==F){
	
		dup<-which(duplicated(fin))
		if(length(dup)>0){
			coor<-coor[-dup,]
			coor2<-coor2[-dup,]
		}
	
	
}

if(refseq_required==F){
	if(is.matrix(coor)==T){
			na<-which(is.na(coor[,"fin"]))
			if(length(na)>0){
				coor[na,"fin"]<-coor[na,"Accesion_number"]
			}
		}
}

# remove entries without Refseq ID
if(refseq_required==T){
	if(is.matrix(coor)==T){
		na<-which(is.na(coor[,"fin"]))
		if(length(na)>0){
			coor<-coor[-na,]
		}
	}
}

# keep only homologs represented in the coprarna reference file	

if(coprarna_compatible==T){
	copref<-read.delim(cop_path, sep="\t", header=T,comment.char = "#")	
		se<-function(x){
			out<-grep(x, copref[,1])[1]
			if(length(out)==0){
				out<-NA
			}
			out
		}
	notinlist<-which(is.na(unlist(lapply(gsub("\\..*","",coor[,"fin"]),se))))
	if(length(notinlist)>0){
		coor<-coor[-notinlist,]	
	}
}

# write fasta file with all sequences that have a assigned Refseq ID and are available for CopraRNA

# fasta3<-c()
		# for(i in 1:nrow(coor)){
			# fasta3<-c(fasta3, paste(">",coor[i,"fin"],"|",gsub(">","",coor[i,"Full_header"]),sep=""))
			# fasta3<-c(fasta3, as.character(coor[i,"sequence"]))
			
		# }
	

# write.table(fasta3, file=outfile, row.names=F, col.names=F, quote=F)


# create short names from organism name and Refseq ID

copref<-read.delim(cop_path, sep="\t", header=T,comment.char = "#")	
nam<-c()
for(i in 1:nrow(coor)){
	tnam<-grep(gsub("\\..*","",coor[i,"fin"]),copref[,1])
	nam<-c(nam,as.character(copref[tnam,2]))
	
	
}

nam2<-c()
for(i in 1:length(nam)){
	temp1<-substr(nam[i],1,3)
	temp2<-strsplit(nam[i],"_")[[1]]
	temp1<-paste(temp1,"_",temp2[2], sep="")
	if(length(temp2)>2){
		temp1<-paste(temp1, temp2[length(temp2)], sep="_")
	}
	nam2<-c(nam2,temp1)
}
nam2<-paste(nam2,coor[,"fin"], sep="_")

coor<-cbind(coor,nam2)
# extract information of sRNA gene neighborhood for synteny analysis and draw synteny pdf

save(coor, file="coor.Rdata")


s<-as.numeric(coor[,3])
e<-as.numeric(coor[,4])
m<-round(s+(e-s)/2,digits=0)

wi<-rep(synteny_window,nrow(coor))

coor3<-cbind(paste(coor[,1],"_",coor[,3],sep=""),coor[,1],m,wi)

write.table(coor3,file="coordinates.txt", sep="\t", row.names=F, col.names=F, quote=F)

#dat<-do.call(rbind,strsplit(system("python3 /media/cyano_share/data/TOOLS/GENBANK_GROPER/genbank_groper.py -p /media/cyano_share/data/TOOLS/GENBANK_GROPER/myPickledData/ -a coordinates.txt", intern=T),"\t"))
dat<-do.call(rbind,strsplit(system("python3 /home/steffen/projects/Dominik_Master_Thesis/Synteny_Network/packages/GENBANK_GROPER_SQLITE/genbank_groper_sqliteDB.py -s /home/steffen/projects/Dominik_Master_Thesis/Synteny_Network/packages/GENBANK_GROPER_SQLITE/mySQLiteDB_new.db -a coordinates.txt", intern=T),"\t"))


unlink("coordinates.txt")
na<-which(dat[,3]=="no annotation")
na2<-which(dat[,3]=="missing entry in LUT")
na<-c(na,na2)

if(length(na)>0){
	dat<-dat[-na,]
}
ids<-unique(dat[,1])

id2<-paste(coor[,1],coor[,3],sep="_")

out<-vector("list", length(ids))
names(out)<-ids
for(i in 1:length(ids)){
	tmp<-which(dat[,1]==ids[i])
	srna<-match(ids[i],id2)
	stra<--1
    if(coor[srna,2]=="+"){
      stra<-1
    }
	temp_out<-cbind(dat[tmp,7],dat[tmp,5],dat[tmp,6],dat[tmp,3],dat[tmp,4],dat[tmp,8])
	colnames(temp_out)<-c("strand","start","end","gene_name","locus_tag","AA_sequence")
	ma<-max(as.numeric(temp_out[,3]))
	mi<-min(as.numeric(temp_out[,2]))
	aa<-as.numeric(temp_out[,2])-mi
	bb<-as.numeric(temp_out[,3])-mi
	s_srna<-min(as.numeric(coor[srna,3:4]))-mi
	e_srna<-max(as.numeric(coor[srna,3:4]))-mi
	nan<-which(is.na(temp_out[,"locus_tag"]))
	na<-which(temp_out[,"locus_tag"]=="na")
	nan<-unique(c(na,nan))
	
	rest<-1:nrow(temp_out)
	if(length(nan)>0){
		temp_out[nan,"locus_tag"]<-unlist(lapply(length(nan),rand_extension,Accession=ids[i]))
		#temp_out[nan,"gene_name"]<-unlist(lapply(temp_out[nan,"gene_name"],rand_extension,Accession=ids[i]))	
		rest<-rest[-nan]
	}
	temp_out[rest,"locus_tag"]<-unlist(lapply(length(rest),rand_extension,Accession=temp_out[rest,"locus_tag"]))
	temp_out<-data.frame(temp_out,aa,bb,rep(s_srna,nrow(temp_out)),rep(e_srna,nrow(temp_out)),rep(stra,nrow(temp_out)),rep(coor[srna,5],nrow(temp_out)))
	# orf<-grep("orf_", temp_out[,"locus_tag"])
	# if(length(orf)>0){
		# temp_out[orf,"locus_tag"]<-paste(tempn[1],temp_out[orf,"locus_tag"], sep="_")
	# }
	
	out[[i]]<-temp_out
	
}


tagtable<-locus_tag2org(out)
get_prot_fasta3(out)
cd<-cdhit_run(psi=F,thres=0.4)
cd<-proc_cdhit(cd)
#plot_function4(out,cd,wind=synteny_window,outformat="pdf", fasta=name)

unlink("protein_fasta.txt")
 cluster_table<-function(cd){
	out<-c()
	for( i in 1:length(cd)){
		temp<-paste(cd[[i]], collapse=",")
		out<-c(out,temp)
	}
	names(out)<-paste("cluster_",1:length(out),sep="")
	out
}

cluster<-cluster_table(cd)
write.table(cluster, file=paste(name,"cluster_table.txt",sep="_"), sep="\t", quote=F)
# write 16S sequences to fasta file 
 
synt_table<-function(out3, coor){
	res<-matrix(,length(out3),6)
	colnames(res)<-c("ID","organism","accesion","refseqID","neighbourhood_genes","position2sRNA")
	for(i in 1:length(out3)){
		tmp<-out3[[i]][order(out3[[i]][,"aa"]),]
		pos<-which(tmp[,"aa"]<tmp[,"rep.s_srna..nrow.temp_out.."])
		pos2<-seq(1,nrow(tmp)-length(pos))
		pos<-c(rev(pos),pos2)
		res[i,1]<-names(out3)[i]
		res[i,2]<-coor[match(gsub("_.*","",names(out3)[i]), coor[,1]),"name"]
		res[i,3]<-coor[match(gsub("_.*","",names(out3)[i]), coor[,1]),1]
		res[i,4]<-coor[match(gsub("_.*","",names(out3)[i]), coor[,1]),"fin"]
		#res[i,5]<-paste(gsub("\"","",out3[[i]][,"locus_tag"]),collapse=",")
		res[i,5]<-paste(gsub("\"","",tmp[,"locus_tag"]),collapse=",")
		res[i,6]<-paste(pos,collapse=",")
	}
	res
}
 
synteny<-synt_table(out,coor)
write.table(synteny, file=paste(name,"synteny_table.txt",sep="_"), sep="\t", quote=F, row.names=F)


